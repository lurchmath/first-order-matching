{
    "docs": [
        {
            "location": "/", 
            "text": "First-Order Matching Documentation\n\n\nGet started now\n\n\nTo import this code via a CDN or \nnpm\n, check out the \nAPI Reference\nPage\n.\n\n\nBackground\n\n\nUnification\n\nis an algorithm that takes two expressions that may contain metavariables\nand produces an instantiation of the metavariables that would make the two\nexpressions equal.  Matching is a special case of unification in which only\none of the two expressions may contain metavariables.\n\n\nMore Information\n\n\nThe following additional information is available in this documentation.\n\n\n\n\nWhitepaper\n - documents the capabilities and limitations of the algorithm in this repository, with proof of correctness\n\n\nSource Code\n - see the source and/or import it into your\n   own project\n\n\nAPI Reference\n - how to use the various functions and\n   objects provided", 
            "title": "Home"
        }, 
        {
            "location": "/#first-order-matching-documentation", 
            "text": "", 
            "title": "First-Order Matching Documentation"
        }, 
        {
            "location": "/#get-started-now", 
            "text": "To import this code via a CDN or  npm , check out the  API Reference\nPage .", 
            "title": "Get started now"
        }, 
        {
            "location": "/#background", 
            "text": "Unification \nis an algorithm that takes two expressions that may contain metavariables\nand produces an instantiation of the metavariables that would make the two\nexpressions equal.  Matching is a special case of unification in which only\none of the two expressions may contain metavariables.", 
            "title": "Background"
        }, 
        {
            "location": "/#more-information", 
            "text": "The following additional information is available in this documentation.   Whitepaper  - documents the capabilities and limitations of the algorithm in this repository, with proof of correctness  Source Code  - see the source and/or import it into your\n   own project  API Reference  - how to use the various functions and\n   objects provided", 
            "title": "More Information"
        }, 
        {
            "location": "/source-code/", 
            "text": "Source Code\n\n\nReading the source\n\n\nThe code in \nthe repository\n\nresides in \none\nfile\n,\nwritten in \nLiterate CoffeeScript\n.\n\n\nChanging the source\n\n\nIf you don't like that language, you can always compile it directly to\nJavaScript with the following command.\n\n\ncoffee --compile first-order-matching.litcoffee\n\n\n\n\nThis assumes that you've \ninstalled\nCoffeeScript\n and have the \nsource\nfile\n\naccessible.\n\n\nImporting the source\n\n\nTo import the source into your project, you can include it directly from a\nCDN at \nthis\nURL\n. There is a\nsource map file in the same folder that your browser should detect.", 
            "title": "Source"
        }, 
        {
            "location": "/source-code/#source-code", 
            "text": "", 
            "title": "Source Code"
        }, 
        {
            "location": "/source-code/#reading-the-source", 
            "text": "The code in  the repository \nresides in  one\nfile ,\nwritten in  Literate CoffeeScript .", 
            "title": "Reading the source"
        }, 
        {
            "location": "/source-code/#changing-the-source", 
            "text": "If you don't like that language, you can always compile it directly to\nJavaScript with the following command.  coffee --compile first-order-matching.litcoffee  This assumes that you've  installed\nCoffeeScript  and have the  source\nfile \naccessible.", 
            "title": "Changing the source"
        }, 
        {
            "location": "/source-code/#importing-the-source", 
            "text": "To import the source into your project, you can include it directly from a\nCDN at  this\nURL . There is a\nsource map file in the same folder that your browser should detect.", 
            "title": "Importing the source"
        }, 
        {
            "location": "/api-reference/", 
            "text": "API Reference\n\n\nGetting started\n\n\nIn the browser\n\n\nImport the minified JavaScript, which you can \ndownload from our repository\ndirectly\n\nor import from a CDN with the following one-liner.\n\n\nscript src='https://cdn.jsdelivr.net/npm/first-order-matching@1/first-order-matching.js'\n/script\n\n\n\n\n\nFrom the command line\n\n\nOr install this package into your project the usual way:\n\n\nnpm install first-order-matching\n\n\n\n\nThen within any of your modules, import it as follows.\n\n\nM = require( \nfirst-order-matching\n );\n\n\n\n\nAfter that, any of the example code snippets in this documentation should\nfunction as-is.\n\n\nUsing OpenMath\n\n\nIn order to do work with mathematical expressions, there needs to be some\ndata structure for storing and some algorithms for manipulating those\nexpressions.  To provide that need, this module depends upon \nan OpenMath\nJavaScript implementation\n.\n\n\nIf you're using this from the command line, and installing it via \nnpm\n,\nthen \nopenmath-js\n will automatically be installed as a dependency of this\none.  Furthermore, it will be accessible through the \nfirst-order-matching\n\nmodule, as shown in the examples below.  (If you import this module as \nM\n,\nthen the OpenMath constructor is accessible as \nM.OM\n.)\n\n\nIf you're using this in the browser, be sure to import the OpenMath\nJavaScript code into your page before importing this one.  You can access it\nfrom the same CDN that you can access this module, as documented on its\nhomepage.  (Follow the link above for the exact URL.)\n\n\nThe remainder of this documentation will assume that you know how to create\nand use OpenMath objects to represent mathematical expressions.  See the\ndocumentation linked to above if needed.\n\n\nMetavariables\n\n\nMatching compares two expressions, one containing metavariables, and\nattempts to create a substitution (a mapping from metavariables to\nexpressions) that, when applied to the expression containing metavariables,\nmakes the two expressions equal.\n\n\nThus it is necessary to be able to flag certain variables in our expressions\nas metavariables, and to detect which variables are metavariables.  The\nfollowing functions are provided in this package for doing so.\n\n\n\n\nsetMetavariable(x)\n - takes an OpenMath variable as input and adds to it\n   an attribute that marks it as a metavariable\n\n\nclearMetavariable(x)\n - removes the attribute added by the previous\n   function\n\n\nisMetavariable(x)\n - true if and only if x is an OpenMath variable with\n   the flag added by \nsetMetavariable()\n\n\n\n\nExamples:\n\n\n\nx = M.OM.var( 'x' );\nM.setMetavariable( x );\nM.isMetavariable( x );\n\n\n\n\n\ny = M.OM.var( 'y' );\nM.isMetavariable( y );\n\n\n\n\nExpression Functions\n\n\nThis module supports patterns that express the application of a function to\na parameter, where the function maps OpenMath expressions to OpenMath\nexpressions, as described in the whitepaper accessible from \nthe main\ndocumentation page\n.  We provide the following API for dealing\nwith such objects.\n\n\n\n\nmakeExpressionFunction(x,b)\n - makes a new expression function with the\n   meaning \nx.b, where x is a variable and b is any OpenMath\n   expression.  The x will be bound in the resulting expression.\n   An error is thrown if x is not a variable.\n\n\nisExpressionFunction(e)\n - returns true if e is an expression of the\n   form created by the previous function, false otherwise.\n\n\nmakeExpressionFunctionApplication(f,a)\n - makes an expression whose\n   meaning is the application of an expression function f to an argument a.\n   Does not verify that f is an expression function; it need not be one, but\n   can be a metavariable, for example.\n\n\nisExpressionFunctionApplication(e)\n - returns true if e is an expression\n   of the form created by the previous function, false otherwise.\n\n\napplyExpressionFunction(f,a)\n - assumes that f has the form of an\n   expression function (i.e., passes \nisExpressionFunction\n) and applies it\n   to the OpenMath expression a.\n\n\nalphaEquivalent(f,g)\n - returns true if and only if both f and g are\n   expression functions and they are \nalpha\n   equivalent\n\n\n\n\n\nef = M.makeExpressionFunction(\n    M.OM.var( 'x' ), M.OM.simple( 'relation1.eq(x,x)' ) );\nM.applyExpressionFunction( ef, M.OM.int( 2 ) ).simpleEncode();\n\n\n\n\n\nM.makeExpressionFunctionApplication(\n    M.OM.var( 'P' ), M.OM.var( 'x' ) ).simpleEncode();\n\n\n\n\nConstraints\n\n\nA constraint is a single pattern-expression pair to be solved by the\nmatching algorithm.  A pattern is an expression containing metavariables,\nand a (plain) expression does not contain metavariables.  We provide this\nAPI for dealing with constraints.\n\n\n\n\nnew Constraint(p,e)\n - creates a new constraint from pattern p and\n   expression e\n\n\nC.pattern\n, \nC.expression\n - access the pattern and expression given at\n   construction time\n\n\nC.copy()\n - copies constraint C deeply\n\n\nC.equals(D)\n - returns true if and only if constraints C and D are\n   structurally equal as pairs, ignoring any OpenMath attributes\n\n\n\n\n\nC = new M.Constraint( M.OM.simple( 'a(b,c)' ), M.OM.simple( 'f(2,3)' ) );\nD = C.copy();\n[ C == D, C.equals( D ) ]\n\n\n\n\nA constraint list is an array of constraints, typically used internally by\nthe matching algorithm to break single constraints down into smaller parts\nto be solved as a set.  Although the matching algorithm can be called on a\nset of constraints, it is typically called on a single constraint.  Even so,\nthis API exists, but is \ndocumented minimally,\nbelow\n, because it is of little interest to\nclients.\n\n\nMatching\n\n\nThe API provides one function for matching, and it is iterative, in the\nsense that if finds the first possible match (if any), and can be called\nagain and again to produce more matches (if there are more).  For this\nreason, its return value is a structure with a few elements.\n\n\n\n\nmatch(constraint)\n - yields a pair of values, one of three\n   possibilities:\n\n\n[ null, null ]\n - there are no solutions to the match (or no more\n  solutions, if this is not the first call)\n\n\n[ solution, null ]\n - there is one solution, given as the first\n  element of the pair, and there are no more after it\n\n\n[ solution, argsArray ]\n - there is more than one solution, but the\n  first is given as the first element of the pair, and the second\n  element of the pair is the array of additional arguments you can pass\n  to \nmatch\n to get it to find more solutions, as documented below.\n\n\n\n\n\n\nmatch(constraint,x,y)\n - if a previous call to \nmatch\n gave you an\n   \nargsArray\n, as documented immediately above, it will contain two values\n   (let's call them x and y) and if we pass them as extra arguments to\n   \nmatch\n, it will seek further solutions to the same matching problem,\n   returning one of the three possibilities above, as with the first call.\n\n\n\n\nValues returned from \nmatch\n are \nConstraintList\n instances in which every\nmember is a pair whose left hand side is a unique metavariable and whose\nright hand side is an OpenMath expression, thus embodying the mapping that\nthe algorithm is designed to produce.  If \nR\n is such a result, you can get\nits list of constraints with \nR.contents\n.\n\n\nExamples:\n\n\nMatching f(x) against f(2) should produce x=2 if x is a metavariable.\n\n\n\npattern = M.OM.simple( 'f(x)' );\nM.setMetavariable( pattern.children[1] );\nexpression = M.OM.simple( 'f(2)' );\nproblem = new M.Constraint( pattern, expression );\npair = M.nextMatch( problem );\nsolution = pair[0].contents;\nfor ( var i = 0 ; i \n<\n solution.length ; i++ )\n    console.log( solution[i].pattern.simpleEncode() + ' --> '\n               + solution[i].expression.simpleEncode() );\n\n\n\n\nMatching f(x) against g(2) should produce f=g and x=2 if both f and x are\nmetavariables.\n\n\n\npattern = M.OM.simple( 'f(x)' );\nM.setMetavariable( pattern.children[0] );\nM.setMetavariable( pattern.children[1] );\nexpression = M.OM.simple( 'g(2)' );\nproblem = new M.Constraint( pattern, expression );\npair = M.nextMatch( problem );\nsolution = pair[0].contents;\nfor ( var i = 0 ; i \n<\n solution.length ; i++ )\n    console.log( solution[i].pattern.simpleEncode() + ' --> '\n               + solution[i].expression.simpleEncode() );\n\n\n\n\nMatching f(x) against f(1,2) should produce no solutions.\n\n\n\npattern = M.OM.simple( 'f(x)' );\nM.setMetavariable( pattern.children[1] );\nexpression = M.OM.simple( 'f(1,2)' );\nproblem = new M.Constraint( pattern, expression );\nM.nextMatch( problem );\n\n\n\n\nMatching f(2) against f(2) should produce an empty solution (i.e., they\nmatch without instantiating any metavariables).\n\n\n\npattern = M.OM.simple( 'f(2)' );\nexpression = M.OM.simple( 'f(2)' );\nproblem = new M.Constraint( pattern, expression );\npair = M.nextMatch( problem );\npair[0].contents\n\n\n\n\nThese have all been trivial examples.  For more complex examples, see the\n\ndozens more examples in the unit test suite, here\n.\nNote that they construct expressions with the \nquick\n function, to make it\neasy to create patterns without calling \nsetMetavariable\n.  That function is\ndefined at the very top of the same file.\n\n\nMinimally Documented Code\n\n\nThe following routines are documented only minimally here, because they are\nalmost never of use to the client of this package.  They are, however,\nexposed by the package in its \nexports\n member, so that they can be subject\nto \nthe unit tests in this\nrepository\n.\n\n\nThe terms and concepts mentioned in this terse documentation are defined in\nthe whitepaper accessible from \nthe main documentation page\n.\n\n\n\n\nconsistentPatterns(p1,p2,...)\n - returns true if and only if the set of\n   patterns p1, p2, etc. is consistent, as defined in \nthe source code\n   documentation here\n.\n\n\nfindDifferencesBetween(e1,e2)\n - an address set expressing the\n   differences between the expressions, as defined in the paper cited above.\n\n\nparentAddresses(addrs)\n - set of parent addresses for all addresses in\n   a given set, as defined in the same paper.\n\n\npartitionedAddresses(e)\n - all addresses for all subexpressions of e,\n   partitioned by equality of the subexpressions at those addresses\n\n\nexpressionDepth(e)\n, \nsameDepthAncestors(e,addrs)\n,\n   \ndifferenceIterator(e1,e2)\n, \nsubexpressionIterator(e)\n,\n   \nprefixIterator(e,iterator)\n, \nsuffixIterator(iterator,e)\n,\n   \ncomposeIterator(iterator,func)\n, \nfilterIterator(iterator,filter)\n,\n   \nconcatenateIterators(first,second)\n - See the thorough documentation for\n   these \nin the source code itself\n.\n\n\nmultiReplace(e,addrs,other)\n, \nbindingConstraints1(pattern)\n,\n   \nsatisfiesBindingConstraints1(solution,constraints)\n,\n   \nbindingConstraints2(pattern)\n,\n   \nsatisfiesBindingConstraints2(solution,constraints)\n - See the thorough documentation for\n   these \nin the source code itself\n.\n\n\n\n\nConstraint list API:\n\n\n\n\nnew ConstraintList(c1,c2,...)\n - creates a constraint list given a list\n   of constraints\n\n\nCL.contents\n - the array used for internal storage, and which is\n   publicly accessible, to be looped over/read/etc.\n\n\nCL.length()\n - number of constraints in the constraint list CL\n\n\nCL.copy()\n - a deep copy with the same order\n\n\nCL.equals(other)\n - equality comparison that ignores order, and uses the\n   \nequals\n member of the \nConstraint\n class\n\n\nCL.plus(c1,c2,...)\n - a new constraint list created by adding the given\n   constraints to the list CL (deep copy, not in-place modification)\n\n\nCL.minus(c1,c2,...)\n - a new constraint list created by removing the\n   given constraints from the list CL (if they were there, doing nothing if\n   they were not -- deep copy, not in-place modification)\n\n\nCL.indexAtWhich(P)\n - first index at which the predicate P holds of the\n   constraint at that index in the list, or -1 if there is no such index\n\n\nCL.firstSatisfying(P)\n - constraint at \nCL.indexAtWhich(P)\n, or null\n\n\nCL.firstPairSatisfying(P)\n - assuming P is a binary predicate accepting\n   two constraints, yields the first pair of indices on whose constraints P\n   returns true, by dictionary ordering the pair of the indices\n\n\nCL.nextNewVariable()\n - generate a new variable that does not appear in\n   any of the constraints in the list CL; this is an iterator that creates\n   an infinite stream of results, different at each call\n\n\nCL.isFunction()\n - whether CL is a function, when viewed as a mapping\n   from the space of metavariables to the space of expressions.  To be so,\n   the constraint list must contain only constraints whose left hand sides\n   are metavariables, and none msut appear in more than one constraint.\n\n\nCL.lookup(x)\n - if \nCL.isFunction()\n then you can look up variables and\n   get back expressions.  Pass a variable as x and this routine does so,\n   returning null if it finds no result.\n\n\nCL.apply(e)\n - if \nCL.isFunction()\n, then you can apply the constraint\n   list CL to the expression e and all metavariables x appearing in e will\n   be replaced simultaneously with the respective result of \nCL.lookup(x)\n\n\n\n\nThis documentation is incomplete!  More coming soon...\n\n\n\n\n\n\nvar elements = document.getElementsByClassName( 'runnable-example' );\nfor ( var i = 0 ; i < elements.length ; i++ ) {\n    var source = elements[i].textContent;\n    elements[i].textContent = '';\n    var notebook = RunKit.createNotebook( {\n        element: elements[i],\n        source: source,\n        preamble: 'M = require( \"first-order-matching\" );'\n    } );\n}", 
            "title": "Reference"
        }, 
        {
            "location": "/api-reference/#api-reference", 
            "text": "", 
            "title": "API Reference"
        }, 
        {
            "location": "/api-reference/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/api-reference/#in-the-browser", 
            "text": "Import the minified JavaScript, which you can  download from our repository\ndirectly \nor import from a CDN with the following one-liner.  script src='https://cdn.jsdelivr.net/npm/first-order-matching@1/first-order-matching.js' /script", 
            "title": "In the browser"
        }, 
        {
            "location": "/api-reference/#from-the-command-line", 
            "text": "Or install this package into your project the usual way:  npm install first-order-matching  Then within any of your modules, import it as follows.  M = require(  first-order-matching  );  After that, any of the example code snippets in this documentation should\nfunction as-is.", 
            "title": "From the command line"
        }, 
        {
            "location": "/api-reference/#using-openmath", 
            "text": "In order to do work with mathematical expressions, there needs to be some\ndata structure for storing and some algorithms for manipulating those\nexpressions.  To provide that need, this module depends upon  an OpenMath\nJavaScript implementation .  If you're using this from the command line, and installing it via  npm ,\nthen  openmath-js  will automatically be installed as a dependency of this\none.  Furthermore, it will be accessible through the  first-order-matching \nmodule, as shown in the examples below.  (If you import this module as  M ,\nthen the OpenMath constructor is accessible as  M.OM .)  If you're using this in the browser, be sure to import the OpenMath\nJavaScript code into your page before importing this one.  You can access it\nfrom the same CDN that you can access this module, as documented on its\nhomepage.  (Follow the link above for the exact URL.)  The remainder of this documentation will assume that you know how to create\nand use OpenMath objects to represent mathematical expressions.  See the\ndocumentation linked to above if needed.", 
            "title": "Using OpenMath"
        }, 
        {
            "location": "/api-reference/#metavariables", 
            "text": "Matching compares two expressions, one containing metavariables, and\nattempts to create a substitution (a mapping from metavariables to\nexpressions) that, when applied to the expression containing metavariables,\nmakes the two expressions equal.  Thus it is necessary to be able to flag certain variables in our expressions\nas metavariables, and to detect which variables are metavariables.  The\nfollowing functions are provided in this package for doing so.   setMetavariable(x)  - takes an OpenMath variable as input and adds to it\n   an attribute that marks it as a metavariable  clearMetavariable(x)  - removes the attribute added by the previous\n   function  isMetavariable(x)  - true if and only if x is an OpenMath variable with\n   the flag added by  setMetavariable()   Examples:  \nx = M.OM.var( 'x' );\nM.setMetavariable( x );\nM.isMetavariable( x );  \ny = M.OM.var( 'y' );\nM.isMetavariable( y );", 
            "title": "Metavariables"
        }, 
        {
            "location": "/api-reference/#expression-functions", 
            "text": "This module supports patterns that express the application of a function to\na parameter, where the function maps OpenMath expressions to OpenMath\nexpressions, as described in the whitepaper accessible from  the main\ndocumentation page .  We provide the following API for dealing\nwith such objects.   makeExpressionFunction(x,b)  - makes a new expression function with the\n   meaning  x.b, where x is a variable and b is any OpenMath\n   expression.  The x will be bound in the resulting expression.\n   An error is thrown if x is not a variable.  isExpressionFunction(e)  - returns true if e is an expression of the\n   form created by the previous function, false otherwise.  makeExpressionFunctionApplication(f,a)  - makes an expression whose\n   meaning is the application of an expression function f to an argument a.\n   Does not verify that f is an expression function; it need not be one, but\n   can be a metavariable, for example.  isExpressionFunctionApplication(e)  - returns true if e is an expression\n   of the form created by the previous function, false otherwise.  applyExpressionFunction(f,a)  - assumes that f has the form of an\n   expression function (i.e., passes  isExpressionFunction ) and applies it\n   to the OpenMath expression a.  alphaEquivalent(f,g)  - returns true if and only if both f and g are\n   expression functions and they are  alpha\n   equivalent   \nef = M.makeExpressionFunction(\n    M.OM.var( 'x' ), M.OM.simple( 'relation1.eq(x,x)' ) );\nM.applyExpressionFunction( ef, M.OM.int( 2 ) ).simpleEncode();  \nM.makeExpressionFunctionApplication(\n    M.OM.var( 'P' ), M.OM.var( 'x' ) ).simpleEncode();", 
            "title": "Expression Functions"
        }, 
        {
            "location": "/api-reference/#constraints", 
            "text": "A constraint is a single pattern-expression pair to be solved by the\nmatching algorithm.  A pattern is an expression containing metavariables,\nand a (plain) expression does not contain metavariables.  We provide this\nAPI for dealing with constraints.   new Constraint(p,e)  - creates a new constraint from pattern p and\n   expression e  C.pattern ,  C.expression  - access the pattern and expression given at\n   construction time  C.copy()  - copies constraint C deeply  C.equals(D)  - returns true if and only if constraints C and D are\n   structurally equal as pairs, ignoring any OpenMath attributes   \nC = new M.Constraint( M.OM.simple( 'a(b,c)' ), M.OM.simple( 'f(2,3)' ) );\nD = C.copy();\n[ C == D, C.equals( D ) ]  A constraint list is an array of constraints, typically used internally by\nthe matching algorithm to break single constraints down into smaller parts\nto be solved as a set.  Although the matching algorithm can be called on a\nset of constraints, it is typically called on a single constraint.  Even so,\nthis API exists, but is  documented minimally,\nbelow , because it is of little interest to\nclients.", 
            "title": "Constraints"
        }, 
        {
            "location": "/api-reference/#matching", 
            "text": "The API provides one function for matching, and it is iterative, in the\nsense that if finds the first possible match (if any), and can be called\nagain and again to produce more matches (if there are more).  For this\nreason, its return value is a structure with a few elements.   match(constraint)  - yields a pair of values, one of three\n   possibilities:  [ null, null ]  - there are no solutions to the match (or no more\n  solutions, if this is not the first call)  [ solution, null ]  - there is one solution, given as the first\n  element of the pair, and there are no more after it  [ solution, argsArray ]  - there is more than one solution, but the\n  first is given as the first element of the pair, and the second\n  element of the pair is the array of additional arguments you can pass\n  to  match  to get it to find more solutions, as documented below.    match(constraint,x,y)  - if a previous call to  match  gave you an\n    argsArray , as documented immediately above, it will contain two values\n   (let's call them x and y) and if we pass them as extra arguments to\n    match , it will seek further solutions to the same matching problem,\n   returning one of the three possibilities above, as with the first call.   Values returned from  match  are  ConstraintList  instances in which every\nmember is a pair whose left hand side is a unique metavariable and whose\nright hand side is an OpenMath expression, thus embodying the mapping that\nthe algorithm is designed to produce.  If  R  is such a result, you can get\nits list of constraints with  R.contents .  Examples:  Matching f(x) against f(2) should produce x=2 if x is a metavariable.  \npattern = M.OM.simple( 'f(x)' );\nM.setMetavariable( pattern.children[1] );\nexpression = M.OM.simple( 'f(2)' );\nproblem = new M.Constraint( pattern, expression );\npair = M.nextMatch( problem );\nsolution = pair[0].contents;\nfor ( var i = 0 ; i  <  solution.length ; i++ )\n    console.log( solution[i].pattern.simpleEncode() + ' --> '\n               + solution[i].expression.simpleEncode() );  Matching f(x) against g(2) should produce f=g and x=2 if both f and x are\nmetavariables.  \npattern = M.OM.simple( 'f(x)' );\nM.setMetavariable( pattern.children[0] );\nM.setMetavariable( pattern.children[1] );\nexpression = M.OM.simple( 'g(2)' );\nproblem = new M.Constraint( pattern, expression );\npair = M.nextMatch( problem );\nsolution = pair[0].contents;\nfor ( var i = 0 ; i  <  solution.length ; i++ )\n    console.log( solution[i].pattern.simpleEncode() + ' --> '\n               + solution[i].expression.simpleEncode() );  Matching f(x) against f(1,2) should produce no solutions.  \npattern = M.OM.simple( 'f(x)' );\nM.setMetavariable( pattern.children[1] );\nexpression = M.OM.simple( 'f(1,2)' );\nproblem = new M.Constraint( pattern, expression );\nM.nextMatch( problem );  Matching f(2) against f(2) should produce an empty solution (i.e., they\nmatch without instantiating any metavariables).  \npattern = M.OM.simple( 'f(2)' );\nexpression = M.OM.simple( 'f(2)' );\nproblem = new M.Constraint( pattern, expression );\npair = M.nextMatch( problem );\npair[0].contents  These have all been trivial examples.  For more complex examples, see the dozens more examples in the unit test suite, here .\nNote that they construct expressions with the  quick  function, to make it\neasy to create patterns without calling  setMetavariable .  That function is\ndefined at the very top of the same file.", 
            "title": "Matching"
        }, 
        {
            "location": "/api-reference/#minimally-documented-code", 
            "text": "The following routines are documented only minimally here, because they are\nalmost never of use to the client of this package.  They are, however,\nexposed by the package in its  exports  member, so that they can be subject\nto  the unit tests in this\nrepository .  The terms and concepts mentioned in this terse documentation are defined in\nthe whitepaper accessible from  the main documentation page .   consistentPatterns(p1,p2,...)  - returns true if and only if the set of\n   patterns p1, p2, etc. is consistent, as defined in  the source code\n   documentation here .  findDifferencesBetween(e1,e2)  - an address set expressing the\n   differences between the expressions, as defined in the paper cited above.  parentAddresses(addrs)  - set of parent addresses for all addresses in\n   a given set, as defined in the same paper.  partitionedAddresses(e)  - all addresses for all subexpressions of e,\n   partitioned by equality of the subexpressions at those addresses  expressionDepth(e) ,  sameDepthAncestors(e,addrs) ,\n    differenceIterator(e1,e2) ,  subexpressionIterator(e) ,\n    prefixIterator(e,iterator) ,  suffixIterator(iterator,e) ,\n    composeIterator(iterator,func) ,  filterIterator(iterator,filter) ,\n    concatenateIterators(first,second)  - See the thorough documentation for\n   these  in the source code itself .  multiReplace(e,addrs,other) ,  bindingConstraints1(pattern) ,\n    satisfiesBindingConstraints1(solution,constraints) ,\n    bindingConstraints2(pattern) ,\n    satisfiesBindingConstraints2(solution,constraints)  - See the thorough documentation for\n   these  in the source code itself .   Constraint list API:   new ConstraintList(c1,c2,...)  - creates a constraint list given a list\n   of constraints  CL.contents  - the array used for internal storage, and which is\n   publicly accessible, to be looped over/read/etc.  CL.length()  - number of constraints in the constraint list CL  CL.copy()  - a deep copy with the same order  CL.equals(other)  - equality comparison that ignores order, and uses the\n    equals  member of the  Constraint  class  CL.plus(c1,c2,...)  - a new constraint list created by adding the given\n   constraints to the list CL (deep copy, not in-place modification)  CL.minus(c1,c2,...)  - a new constraint list created by removing the\n   given constraints from the list CL (if they were there, doing nothing if\n   they were not -- deep copy, not in-place modification)  CL.indexAtWhich(P)  - first index at which the predicate P holds of the\n   constraint at that index in the list, or -1 if there is no such index  CL.firstSatisfying(P)  - constraint at  CL.indexAtWhich(P) , or null  CL.firstPairSatisfying(P)  - assuming P is a binary predicate accepting\n   two constraints, yields the first pair of indices on whose constraints P\n   returns true, by dictionary ordering the pair of the indices  CL.nextNewVariable()  - generate a new variable that does not appear in\n   any of the constraints in the list CL; this is an iterator that creates\n   an infinite stream of results, different at each call  CL.isFunction()  - whether CL is a function, when viewed as a mapping\n   from the space of metavariables to the space of expressions.  To be so,\n   the constraint list must contain only constraints whose left hand sides\n   are metavariables, and none msut appear in more than one constraint.  CL.lookup(x)  - if  CL.isFunction()  then you can look up variables and\n   get back expressions.  Pass a variable as x and this routine does so,\n   returning null if it finds no result.  CL.apply(e)  - if  CL.isFunction() , then you can apply the constraint\n   list CL to the expression e and all metavariables x appearing in e will\n   be replaced simultaneously with the respective result of  CL.lookup(x)", 
            "title": "Minimally Documented Code"
        }, 
        {
            "location": "/api-reference/#this-documentation-is-incomplete-more-coming-soon", 
            "text": "var elements = document.getElementsByClassName( 'runnable-example' );\nfor ( var i = 0 ; i < elements.length ; i++ ) {\n    var source = elements[i].textContent;\n    elements[i].textContent = '';\n    var notebook = RunKit.createNotebook( {\n        element: elements[i],\n        source: source,\n        preamble: 'M = require( \"first-order-matching\" );'\n    } );\n}", 
            "title": "This documentation is incomplete!  More coming soon..."
        }
    ]
}