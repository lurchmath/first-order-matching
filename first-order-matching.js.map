{"version":3,"sources":["first-order-matching.litcoffee"],"names":["CLSetToString","CLToString","CToString","Constraint","ConstraintList","OM","OMNode","ProblemStore","alphaEquivalent","applyExpressionFunction","bindingConstraints1","bindingConstraints2","clearMetavariable","composeIterator","concatenateIterators","consistentPatterns","differenceIterator","expressionDepth","expressionFunction","expressionFunctionApplication","filterIterator","findDifferencesBetween","getSolution","isExpressionFunction","isExpressionFunctionApplication","isMetavariable","makeExpressionFunction","makeExpressionFunctionApplication","matchDebug","matchDebugOn","metavariableSymbol","multiReplace","newProblem","nextMatch","parentAddresses","partitionedAddresses","prefixIterator","ref","sameDepthAncestors","satisfiesBindingConstraints1","satisfiesBindingConstraints2","setMatchDebug","setMetavariable","subexpressionIterator","suffixIterator","trueValue","slice","require","WorkerGlobalScope","importScripts","self","symbol","string","variable","ref1","type","setAttribute","copy","metavariable","removeAttribute","ref2","getAttribute","equals","body","bin","expression","variables","length","func","argument","app","children","result","replaceFree","func1","func2","apply1","apply2","index","isNewVar","newVar","pair","expr","hasDescendantSatisfying","M","functionMetavariables","j","k","len","len1","nonFunctionMetavariables","patterns","ref3","ref4","ref5","arguments","call","descendantsSatisfying","parent","findInParent","name","indexOf","push","pattern1","expression3","this","pattern","other","checkVariable","constraint","contents","l","len2","variablesIn","nextNewVariableIndex","_this","test","Math","max","parseInt","d","nextNewVariable","simple","c","args","ctor","results1","indexAtWhich","predicate","plus","constraints","minus","splice","firstSatisfying","firstPairSatisfying","constraint1","constraint2","index1","index2","isFunction","seenSoFar","lookup","apply","metavariables","value","replaceWith","expression1","expression2","differences","recur","A","B","Ac","Bc","child","address","concat","addresses","results","serialized","JSON","stringify","parse","partition","subexpression","found","part","address1","address2","depth1","depth2","improvement","len3","n","indexedSubexpressionsAreEqual","nextAddressSet","pars","iterator","state","next","shift","rest","subsetIndex","i","x","simpleEncode","pow","element","firstCallHasHappened","suffixHasHappened","filter","first","second","replacement","already","binding","isBinder","m","newConstraint","v","isFree","solution","sv","occursFree","efa","arg","check","ef","isFreeToReplace","cl","join","cls","onoff","console","log","LHS","RHS","alreadySetTo","c1","c2","e","e1","e2","leftChildren","mValue","makeMValue","nextArguments","nextConstraints","nextIterator","nextResult","nextSolution","pseudoChildren","rightChildren","smallerC","t","t1","t2","subset","maybeExtended","newConstraints","newMValue","oldMValue","Error","exports","bc1","bc2","problem","count","success","addEventListener","event","converted","data","decode","encode","postMessage"],"mappings":"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","file":"first-order-matching.js","sourcesContent":["\n# The Matching Module\n\nThis module implements the algorithm documented thoroughly in an unpublished\npaper entitled \"A Limited First Matching Algorithm,\" in the documentation\nfor this package.\n\nIf this is being used from Node.js, the following code will import the\nrequisite OpenMath data structures.  If it is being used from the browser,\nyou should include the source for the OpenMath module first.\n\nSee [openmath-js on npm](http://www.npmjs.org/package/openmath-js).\n\n    if require? then { OM, OMNode } = require 'openmath-js'\n\nIf this file is being used within a WebWorker, then we detect whether it is\nwithin Node.js (for testing by developers) or within a browser's WebWorker.\nDepending on which it is, we include the OpenMath module in a different way.\nIn the testing case, we assume it has been installed by npm in\n`node_modules`.  In the browser case, we assume the developer has placed it\nin the same folder as this script.\n\n    if WorkerGlobalScope? # browser case\n        importScripts 'openmath.js'\n    else if self?.importScripts? # node case\n        importScripts 'node_modules/openmath-js/openmath.js'\n\n## Metavariables\n\nAll of the routines in this section make use of a single common symbol, so\nwe create one instance here for use repeatedly.  We also create an instance\nof a string that signifies a boolean true value, because that will be the\nvalue of the attribute whose key is the metavariable symbol.\n\n    metavariableSymbol = OM.symbol 'metavariable', 'FirstOrderMatching'\n    trueValue = OM.string 'true'\n\nWe begin with a routine that marks a variable as a metavariable.  It accepts\nas parameter any `OMNode` instance (as implemented\n[here](openmath-duo.litcoffee)) and gives it an attribute that the rest of\nthis package recognizes as meaning \"this variable is actually a\nmetavariable.\"  This routine does nothing if the given input is not an\nOMNode of type variable or type symbol.\n\n(It is necessary to permit symbols to be metavariables because there are\nsome positions in an OpenMath tree that can only be occupied by symbols.\nFor instance, if we wished to express the pattern \"forall x, P(x)\" but with\nthe forall symbol replaced by a metavariable, it would need to be a symbol\nin order for the expression to be a valid OpenMath object.)\n\n    setMetavariable = ( variable ) ->\n        if variable not instanceof OMNode or \\\n           variable.type not in [ 'v', 'sy' ] then return\n        variable.setAttribute metavariableSymbol, trueValue.copy()\n\nTo undo the above action, call the following function, which removes the\nattribute.\n\n    clearMetavariable = ( metavariable ) ->\n        metavariable.removeAttribute metavariableSymbol\n\nTo query whether a variable has been marked as a metaviariable, use the\nfollowing routine, which tests for the presence of the attribute in\nquestion.\n\n    isMetavariable = ( variable ) ->\n        variable instanceof OMNode and variable.type in [ 'v', 'sy' ] and \\\n            variable.getAttribute( metavariableSymbol )?.equals trueValue\n\n## Expression functions and expression function applications\n\nThis module supports patterns that express the application of a function to\na parameter, where the function maps OpenMath expressions to OpenMath\nexpressions, as described in the paper cited at the top of this file.  We\nwill represent a function with the following binding head symbol.\n\n    expressionFunction = OM.symbol 'EF', 'FirstOrderMatching'\n\nWe express the application of such a function to an argument as an\napplication of the following symbol.\n\n    expressionFunctionApplication = OM.symbol 'EFA', 'FirstOrderMatching'\n\nSo for example, `P(x)` would be expressed as `OM.simple 'FirstOrderMatching.EFA(P,X)'`\nand the map from input `p` to output `h(x,p,p)` as `OM.simple\n'FirstOrderMatching.EF[p,h(x,p,p)]'`.\n\nWe therefore construct a few convenience functions for testing whether an\nexpression is of one of the types above, and for constructing expressions of\nthose types.\n\n    makeExpressionFunction = ( variable, body ) =>\n        if variable.type isnt 'v' then throw 'When creating an expression\n            function, its parameter must be a variable'\n        OM.bin expressionFunction, variable, body\n    isExpressionFunction = ( expression ) =>\n        expression.type is 'bi' and expression.variables.length is 1 and \\\n            expression.symbol.equals expressionFunction\n    makeExpressionFunctionApplication = ( func, argument ) =>\n        OM.app expressionFunctionApplication, func, argument\n    isExpressionFunctionApplication = ( expression ) =>\n        expression.type is 'a' and expression.children.length is 3 and \\\n            expression.children[0].equals expressionFunctionApplication\n\nYou can also apply expression functions to expressions (unsurprisingly, as\nthat is their purpose).\n\n    applyExpressionFunction = ( func, expression ) ->\n        result = func.body.copy()\n        result.replaceFree func.variables[0], expression\n        result\n\nWe also include a function that tests whether two expression functions are\nalpha equivalent.\n\n    alphaEquivalent = ( func1, func2 ) ->\n        index = 0\n        newVar = -> OM.var \"v#{index}\"\n        isNewVar = ( expr ) -> expr.equals newVar()\n        pair = OM.app func1, func2\n        while pair.hasDescendantSatisfying isNewVar then index++\n        apply1 = applyExpressionFunction func1, newVar()\n        apply2 = applyExpressionFunction func2, newVar()\n        isExpressionFunction( func1 ) and \\\n        isExpressionFunction( func2 ) and apply1.equals apply2\n\n## Consistent patterns\n\nA list of patterns is consistent if every metavariable appearing in any of\nthe patterns in the position of an expression function always appears as an\nexpression function (or equivalently any metavariable appearing anywhere\nother than as the first child of an expression function application never\nappears anywhere as the first child of an expression function application).\n\nThe motivation is that it would be inconsistent to demand that one pattern\ninstantiate a metavariable as an expression function, but another pattern\ndemand that the same metavariable be instantiated as a plain expression.\n\n    consistentPatterns = ( patterns... ) ->\n        nonFunctionMetavariables = [ ]\n        functionMetavariables = [ ]\n        for pattern in patterns\n            for M in pattern.descendantsSatisfying isMetavariable\n                if isExpressionFunctionApplication( M.parent ) and \\\n                        M.findInParent() is 'c1'\n                    if M.name in nonFunctionMetavariables then return no\n                    if M.name not in functionMetavariables\n                        functionMetavariables.push M.name\n                else\n                    if M.name in functionMetavariables then return no\n                    if M.name not in nonFunctionMetavariables\n                        nonFunctionMetavariables.push M.name\n        yes\n\n## Constraint class\n\nA constraint is a pair of OpenMath expressions, the first of which will be\ninterpreted as a pattern, and the second as an expression.  Constraints can\nbe used as part of a problem to solve, or as part of a solution.  When they\nare part of a solution, the pattern is always a lone metavariable.\n\n    class Constraint\n\nConstruct a constraint by providing the pattern and the expression.\n\n        constructor : ( @pattern, @expression ) ->\n\nThey can be copied by copying each component.\n\n        copy : -> new Constraint @pattern.copy(), @expression.copy()\n\nTwo are equal if their components are equal.\n\n        equals : ( other ) ->\n            @pattern.equals( other.pattern, no ) and \\\n            @expression.equals( other.expression, no )\n\n## Constraint list class\n\nA constraint list is simply an array of constraints, with a few convenience\nfunctions added for adding, removing, and searching in a way unique to lists\nof constraints.  It can be used to express a problem as a list of\nconstraints, or a solution as a list of metavariable-expression pairs.\n\n    class ConstraintList\n\nConstruct a constraint list by providing zero or more constraints to add to\nit initially.  Besides simply storing those constraints, this function also\ncomputes the first variable from the list `v0`, `v1`, `v2`, ... such that it\nnor any variable after it in that list appears in any of the constraints.\nCall it `vn`.  Then later the `newVariable` member can be called in this\nobject at any time to generate an infinite stream of new variables starting\nwith `vn`.\n\n        constructor : ( @contents... ) ->\n            @nextNewVariableIndex = 0\n            checkVariable = ( variable ) =>\n                if /^v[0-9]+$/.test variable.name\n                    @nextNewVariableIndex = Math.max @nextNewVariableIndex,\n                        parseInt( variable.name[1..] ) + 1\n            variablesIn = ( expression ) ->\n                expression.descendantsSatisfying ( d ) -> d.type is 'v'\n            for constraint in @contents\n                for variable in variablesIn constraint.pattern\n                    checkVariable variable\n                for variable in variablesIn constraint.expression\n                    checkVariable variable\n\nGenerating new variables, as documented in the previous function, is\naccomplished by this function.\n\n        nextNewVariable : -> OM.simple \"v#{@nextNewVariableIndex++}\"\n\nThe length of the constraint list is just the length of its contents array.\n\n        length : -> @contents.length\n\nYou can create a copy by just creating a copy of all the entries.  If this\nobject has not had any constraints modified or removed since its creation,\nthat simple kind of copy would naturally result in the correct value of\n`nextNewVariableIndex` in the copy, but of course this object may have had\nsome constraints modified or removed since its creation, so we copy that\ndatum over explicitly.\n\n        copy : ->\n            result = new ConstraintList ( c.copy() for c in @contents )...\n            result.nextNewVariableIndex = @nextNewVariableIndex\n            result\n\nThe following function is mostly for internal use, in defining functions\nbelow.  It finds the first index at which the given predicate holds of the\nconstraint at that index, or returns -1 if there is no such index.\n\n        indexAtWhich : ( predicate ) ->\n            for constraint, index in @contents\n                if predicate constraint then return index\n            -1\n\nThis function adds constraints to the list, but each constraint is only\nadded if it's not already on the list (using the `equals` member of the\nconstraint class for comparison).\n\n        plus : ( constraints... ) ->\n            result = @copy()\n            for constraint in constraints\n                index = result.indexAtWhich ( c ) -> c.equals constraint, no\n                if index is -1 then result.contents.push constraint\n            result\n\nThis function removes constraints from the list.  Any constraint passed that\nis not on the list is silently ignored.\n\n        minus : ( constraints... ) ->\n            result = @copy()\n            for constraint in constraints\n                index = result.indexAtWhich ( c ) -> c.equals constraint, no\n                if index > -1 then result.contents.splice index, 1\n            result\n\nThis function returns the first constraint in the list satisfying the given\npredicate, or null if there is not one.\n\n        firstSatisfying : ( predicate ) ->\n            @contents[@indexAtWhich predicate] ? null\n\nThis function returns a length-two array containing the first two\nconstraints satisfying the given binary predicate, or null if there is not\none.  In this case, \"first\" means by dictionary ordering the pair of the\nindices of the two constraints returned.  If there is no such pair, this\nreturns null.\n\n        firstPairSatisfying : ( predicate ) ->\n            for constraint1, index1 in @contents\n                for constraint2, index2 in @contents\n                    if index1 isnt index2\n                        if predicate constraint1, constraint2\n                            return [ constraint1, constraint2 ]\n            null\n\nSome constraint lists are functions from the space of metavariables to the\nspace of expressions.  To be such a function, the constraint list must\ncontain only constraints whose left hand sides are metavariables, and none\nmsut appear in more than one constraint.  This function determines whether\nthat is true.\n\n        isFunction : ->\n            seenSoFar = [ ]\n            for constraint in @contents\n                if not isMetavariable constraint.pattern then return no\n                if constraint.pattern.name in seenSoFar then return no\n                seenSoFar.push constraint.pattern.name\n            yes\n\nA constraint list that is a function can be used as a lookup table.  This\nroutine implements the lookup function.  It can accept a variable (an\n`OMNode` object) or just the name of one (a string) as argument.  This\nroutine finds the first pair in the list for which that variable name is the\nleft hand side, and returns the right hand side.  If `isFunction()` is true,\nthen it will be the only such pair.  If ther is no such pair, this returns\nnull.\n\nThe input, if it is an OMNode, will have its metavariable flag set.  If you\ndo not want your input changed, pass a copy.  The result will be the actual\nOMNode that is in the other half of the constraint pair.  If you plan to\nmodify it, make a copy.\n\n        lookup : ( variable ) ->\n            if variable not instanceof OM then variable = OM.var variable\n            setMetavariable variable\n            for constraint in @contents\n                if constraint.pattern.equals variable, no\n                    return constraint.expression\n            null\n\nYou can also apply a constraint list that is a function to a larger\nexpression containing metavariables, to replace them all at once.  This\nmember function does so, after first creating a copy of the expression, so\nas not to alter the original.\n\n        apply : ( expression ) ->\n            result = expression.copy()\n            metavariables = result.descendantsSatisfying isMetavariable\n            for metavariable in metavariables\n                if ( value = @lookup metavariable )?\n                    metavariable.replaceWith value\n            result\n\nTwo constraint lists are equal if a pair in either is also in the other.\n\n        equals : ( other ) ->\n            for constraint in @contents\n                if not other.firstSatisfying( ( c ) -> c.equals constraint )\n                    return no\n            for constraint in other.contents\n                if not @firstSatisfying( ( c ) -> c.equals constraint )\n                    return no\n            yes\n\n## Differences and parent addresses\n\nThe notion of an address is defined in [the OpenMath\nmodule](../src/openmath-duo.litcoffee).\n\nThis function computes the set of addresses at which two expressions differ.\nIt uses an internal recursive function that fills a list that's initially\nempty.\n\n    findDifferencesBetween = ( expression1, expression2 ) ->\n        differences = [ ]\n        recur = ( A, B ) ->\n            if A.type isnt B.type\n                return differences.push A.address expression1\n            if A.type is 'bi'\n                Ac = [ A.symbol, A.variables..., A.body ]\n                Bc = [ B.symbol, B.variables..., B.body ]\n            else\n                Ac = A.children\n                Bc = B.children\n            if Ac.length isnt Bc.length or \\\n               ( Ac.length + Bc.length is 0 and not A.equals B, no )\n                differences.push A.address expression1\n            else\n                recur child, Bc[index] for child, index in Ac\n        recur expression1, expression2\n        differences\n\nGiven a set of addresses, we can compute the set of parent addresses of\nthose addresses.  This function does so, but using lists in place of sets.\nNote that the empty address has no parent, so if we ask what the set of\nparent addresses are of [ empty address ], we get null.\n\n    parentAddresses = ( addresses ) ->\n        results = [ ]\n        for address in addresses\n            if address.length is 0 then continue\n            serialized = JSON.stringify address[...-1]\n            if serialized not in results then results.push serialized\n        if results.length is 0 then return null\n        JSON.parse address for address in results\n\n## Subexpressions\n\nThe following function partitions the addresses of all subexpressions of\nthe given expression into equivalence classes by equality of subexpressions\nat those addresses.  Each part in the partition is actually an object with\ntwo members, one being the subexpression and the other being the set of\naddresses at which it occurs.\n\n    partitionedAddresses = ( expression ) ->\n        partition = []\n        recur = ( subexpression ) ->\n            found = no\n            for part in partition\n                if subexpression.equals part.subexpression, no\n                    part.addresses.push subexpression.address expression\n                    found = yes\n                    break\n            if not found then partition.push\n                subexpression : subexpression\n                addresses : [ subexpression.address expression ]\n            recur child for child in subexpression.children\n        recur expression\n        partition\n\n## Iterators\n\nFor the purposes of this file, an iterator is a function that, when called\nwith zero arguments, returns new values from each call, until it eventually\nreturns null (which is a fixed point, and it will continue to return null\nfor all subsequent calls).\n\nGiven two expressions $e_1$ and $e_2$, compute their difference set, as\ndefined in the paper cited at the top of this document, and call it $D$.\nLet $A$ be the set of ancestor sets to $D$ that are uniform on both $e_1$\nand $e_2$.  This iterator enumerates $A$.\n\nIt relies on the fact that, in order for an address set to be uniform on any\nexpression, the addresses in the set must all be to subtrees of the same\nheight.  Thus the first step of the iteration is to shrink the addresses in\na difference set until all subtrees have the same height.  Then we can\nenumerate $A$ by simply repeatedly computing parent addresses of the entire\nset.  This makes the enumeration linear.  Consequently, we need the\nfollowing handy function.\n\n    expressionDepth = ( expression ) ->\n        children = [ expression.children..., expression.variables... ]\n        if expression.body then children.push expression.body\n        if expression.symbol then children.push expression.symbol\n        1 + Math.max 0, ( expressionDepth child for child in children )...\n\nGiven a set $S$ of addresses into an expression $e$, with varying depths of\nsubtrees $e[s]$ for $s\\in S$, we will want to compute the set of ancestors\nof addresses in $S$ whose subexpressions in $e$ all have the same depth, the\nmaximum depth of the $e[s]$ for $s\\in S$.  This function does so.  Note that\nit never returns an empty array (if the input list was nonempty) because the\naddress `[]` is an ancestor to every address, and so the set `[ [] ]` will\nalways be a valid same-depth ancestor set to the input (though possibly not\nthe minimum depth one).\n\n    sameDepthAncestors = ( expression, addresses ) ->\n\nTry to find a pair of addresses of different depths.\n\n        for address1, index1 in addresses\n            depth1 = expressionDepth expression.index address1\n            for address2, index2 in addresses\n                depth2 = expressionDepth expression.index address2\n                if depth1 is depth2 then continue\n\nEnsure the shallower is #1 and the deeper is #2, then deepen #1.\n\n                if depth1 > depth2\n                    [ address1, address2 ] = [ address2, address1 ]\n                    [ index1, index2 ] = [ index2, index1 ]\n                deeper = address1[...-1]\n\nReplace the old, shallower version with its deeper version, then recur.\n\n                improvement = addresses[..]\n                improvement[index1] = address1[...-1]\n                return sameDepthAncestors expression, improvement\n\nIf there was no pair of addresses of different depths, then we just remove\nduplicates to ensure that this is a set, and we're done.\n\n        results = []\n        for address in addresses\n            serialized = JSON.stringify address\n            if serialized not in results then results.push serialized\n        JSON.parse serialized for serialized in results\n\nNow we can use those two functions to build the difference iterator\nspecified at the start of this section.  Note that it assumes that the two\nexpressions passed in are not equal, so that there exists a difference set.\n\n    differenceIterator = ( expression1, expression2 ) ->\n        nextAddressSet = sameDepthAncestors expression1, \\\n            findDifferencesBetween expression1, expression2\n        indexedSubexpressionsAreEqual = ( addresses ) ->\n            for address1 in addresses\n                for address2 in addresses\n                    if not expression1.index( address1 ).equals \\\n                            expression1.index( address2 ), no then return no\n                    if not expression2.index( address1 ).equals \\\n                            expression2.index( address2 ), no then return no\n            yes\n        ->\n            while nextAddressSet? and \\\n                  not indexedSubexpressionsAreEqual nextAddressSet\n                pars = parentAddresses nextAddressSet\n                nextAddressSet =\n                    pars and sameDepthAncestors expression1, pars\n            result = nextAddressSet\n            if result isnt null\n                pars = parentAddresses nextAddressSet\n                nextAddressSet =\n                    pars and sameDepthAncestors expression1, pars\n            result\n\nGiven an expression $e$, we consider the set of all subexpressions $U$ of\n$e$, and say that they are labeled $u_1,\\ldots,u_n$.  For any $u_i$, let\n$A_{u_i}$ be the set of addresses (in the sense defined in [the OpenMath\nmodule](../src/openmath-duo.litcoffee)) to all instances of $u_i$ in $e$.\nFor each $A_{u_i}$, we enumerate its nonempty subsets, and call them\n$S_{i,1},\\ldots,S_{i,m_i}$.  This iterator returns the list\n$S_{1,1},S_{1,2},\\ldots,S_{n,m_n}$, followed by the string `'done'`.\n\n    subexpressionIterator = ( expression ) ->\n        partition = partitionedAddresses expression\n        state =\n            next : partition.shift()\n            rest : partition\n            subsetIndex : 1\n        iterator = ->\n            matchDebug '\\t\\tsubexpression iterator for',\n                expression.simpleEncode(), 'next:',\n                JSON.stringify( state.next.addresses ), 'rest:',\n                JSON.stringify( ( x.addresses for x in state.rest ) ),\n                'subsetIndex:', state.subsetIndex\n            if state.subsetIndex < 2 ** state.next.addresses.length\n                result = ( state.next.addresses[i] \\\n                    for i in [0...state.next.addresses.length] \\\n                    when 0 < ( state.subsetIndex & 2 ** i ) )\n                state.subsetIndex++\n                return result\n            if state.rest.length > 0\n                state.next = state.rest.shift()\n                state.subsetIndex = 1\n                return iterator()\n            return null\n        iterator\n\nThe following function takes an iterator and an element, and yields a new\niterator whose return list is the same as that of the given iterator, but\nprefixed with the new element (just once).\n\n    prefixIterator = ( element, iterator ) ->\n        firstCallHasHappened = no\n        ->\n            if firstCallHasHappened then return iterator()\n            firstCallHasHappened = yes\n            element\n\nThe following function takes an iterator and an element, and yields a new\niterator whose return list is the same as that of the given iterator, but\nsuffixed with the new element (just once).\n\n    suffixIterator = ( iterator, element ) ->\n        suffixHasHappened = no\n        ->\n            result = iterator()\n            if result is null and not suffixHasHappened\n                result = element\n                suffixHasHappened = yes\n            result\n\nThe following function takes an iterator and composes it with a function,\nreturning a new iterator that returns a list each of whose values is the\nsame as the old iterator would have returned, but first passed through the\ngiven function.\n\n    composeIterator = ( iterator, func ) ->\n        -> if result = iterator() then func result else null\n\nThe following function takes an iterator and a filter.  It yields a new\niterator that yields a subsequence of what the given iterator yields,\nspecifically exactly those results that pass the test of the filter.\n\n    filterIterator = ( iterator, filter ) ->\n        ->\n            next = iterator()\n            while next and not filter next then next = iterator()\n            next\n\nThe following function takes two iterators and concatenates them, returning\na new iterator that returns first all the items from the first iterator (not\nincluding the terminating null sequence), followed by all the items from the\nsecond iterator (including the terminating null sequence).\n\n    concatenateIterators =\n        ( first, second ) -> -> first() or second()\n\n## Matching\n\nThe matching algorithm below makes use of the notion of replacing several\nsubexpressions of a larger expression at once.  The following function\naccomplishes this.  It replaces every subexpression of the given expression\nat any one of the given addresses with a copy of the replacement expression.\n\n    multiReplace = ( expression, addresses, replacement ) ->\n        result = expression.copy()\n        for address in addresses\n            result.index( address )?.replaceWith replacement.copy()\n        result\n\nThe matching algorithm implemented at the end of this file does not take\nrestrictions fo bound/free variables into account.  Clients who care about\nthat distinction should extract from the constraint set the bound/free\nrestrictions using the following function, then test to see if a solution\nobeys them using the function after that.\n\nThis first function extracts from a pattern a list of metavariable pairs\n(m1,m2).  Such a pair means the restriction that a solution s cannot have\ns(m1) appearing free in s(m2).  Pairs are represented as instances of the\n`Constraint` class, and lists of pairs as a `ConstraintList`.\n\n    bindingConstraints1 = ( pattern ) ->\n        result = new ConstraintList()\n        isBinder = ( d ) -> d.type is 'bi'\n        for binding in pattern.descendantsSatisfying isBinder\n            for m in binding.descendantsSatisfying isMetavariable\n                if not m.isFree binding then continue\n                for v in binding.variables\n                    if not isMetavariable v then continue\n                    newConstraint = new Constraint v, m\n                    already = ( c ) -> c.equals newConstraint\n                    if not result.firstSatisfying already\n                        result.contents.push newConstraint\n        result\n\nThis second function tests whether a given solution (expressed as a\n`ConstraintList` instance) obeys a set of binding constraints (expressed as\nanother `ConstraintList` instance) computed by `bindingConstraints1`.  It\nreturns a boolean.\n\n    satisfiesBindingConstraints1 = ( solution, constraints ) ->\n        for constraint in constraints.contents\n            sv = solution.lookup constraint.pattern\n            sm = solution.lookup( constraint.expression ).copy()\n            if sm.occursFree sv then return no\n        yes\n\nThis third function extracts from a pattern a list of pairs (P,x) such that\nthe expression function application P(x) appeared in the pattern.  Such a\npair means the restriction that a solution s must have s(x) free to have\ns(P) applied to it.  Pairs are represented as instances of the `Constraint`\nclass, and lists of pairs as a `ConstraintList`.\n\n    bindingConstraints2 = ( pattern ) ->\n        result = new ConstraintList()\n        for efa in pattern.descendantsSatisfying \\\n                isExpressionFunctionApplication\n            if not isMetavariable efa.children[1] then continue\n            newConstraint = new Constraint efa.children[1..2]...\n            if not result.firstSatisfying( ( c ) -> c.equals newConstraint )\n                result.contents.push newConstraint\n        result\n\nThis fourth function tests whether a given solution (expressed as a\n`ConstraintList` instance) obeys a set of binding constraints (expressed as\nanother `ConstraintList` instance) computed by `bindingConstraints2`.  It\nreturns a boolean.\n\n    satisfiesBindingConstraints2 = ( solution, constraints ) ->\n        for constraint in constraints.contents\n            ef = solution.lookup constraint.pattern\n            if not ef?\n                matchDebug CLToString( solution ), CLToString( constraints )\n            arg = solution.apply constraint.expression\n            check = ( d ) -> d.equals ef.variables[0]\n            for v in ef.body.descendantsSatisfying check\n                if not arg.isFreeToReplace v, ef.body then return no\n        yes\n\nThe following function, when iterated, will compute all valid solutions to\na given constraint set.  It returns pairs as length-two arrays.  A return\nvalue of `[A,B]` is a solution `A` and the necessary data `B` to iterate the\ncall.  Specifically, `B` will be a triple suitable for passing as the three\narguments to another call to `nextMatch`, so that one could call\n`nextMatch B...` for example.  When `B` is null, there are no more\nsolutions to be found.\n\nClients should not pass a value to the third parameter, which is for\ninternal use only, in recursion.  Clients may optionally pass a value for\nthe second parameter, as a solution to extend, but this is not the norm.\n\nFirst, some debugging routines that are able to be turned on and off, for\ndevelopment purposes.\n\n    CToString = ( c ) ->\n        \"(#{c.pattern.simpleEncode()},#{c.expression.simpleEncode()})\"\n    CLToString = ( cl ) ->\n        if cl is null then return null\n        \"{ #{( CToString(c) for c in cl.contents ).join ', '} }\"\n    CLSetToString = ( cls ) ->\n        if cls is null then return null\n        '[\\n' + ( \"\\t#{CLToString(cl)}\" for cl in cls ).join( '\\n' ) + '\\n]'\n    matchDebugOn = no\n    setMatchDebug = ( onoff ) -> matchDebugOn = onoff\n    matchDebug = ( args... ) -> if matchDebugOn then console.log args...\n\nNow, the matching algorithm.\n\n    nextMatch = ( constraints,\n                  solution = new ConstraintList(),\n                  iterator = null ) ->\n\nIf this function was called with a single constraint in the first position,\nrather than a list of them, then convert it to the correct type.\n\n        if constraints instanceof Constraint\n            constraints = new ConstraintList constraints\n        if constraints not instanceof ConstraintList\n            throw 'Invalid first parameter, not a constraint list'\n        matchDebug '\\nmatchDebug', CLToString( constraints ),\n            CLToString( solution ),\n            if iterator? then '  ...ITERATOR...' else ''\n\nIf we have not been given an iterator, then proceed with normal matching.\nWhen we have an iterator, it means we must take a union over a series of\nmatching problems; we'll handle that case at the end of this function, far\nbelow.\n\n        if not iterator?\n\nBase case:  If we have consumed all the constraints, then the solution we\nhave constructed is the only result.\n\n            if constraints.length() is 0\n                matchDebug '\\tbase case, returning:', CLToString solution\n                return [ solution, null ]\n\nAtomic case:  If there is a constraint whose left hand side is atomic and\nnot a metavariable, then it must perfectly match the right hand side.\n\n            constraint = constraints.firstSatisfying ( c ) ->\n                c.pattern.children.length is 0 and \\\n                c.pattern.variables.length is 0 and \\\n                not isMetavariable c.pattern\n            if constraint?\n                return \\\n                if constraint.pattern.equals constraint.expression, no\n                    matchDebug '\\tatomic case, recur:', CToString constraint\n                    nextMatch constraints.minus( constraint ), solution,\n                        iterator\n                else\n                    matchDebug '\\tatomic case, return null for',\n                        CToString constraint\n                    [ null, null ]\n\nNon-atomic case:  If there is a constraint whose left hand side is\nnon-atomic and not an expression function application, then we try to break\nit down into sub-constraints, as long as the right hand side admits a\ncorresponding decomposition.\n\n            pseudoChildren = ( expr ) ->\n                if expr.type is 'bi'\n                    [ expr.symbol, expr.variables..., expr.body ]\n                else\n                    expr.children\n            constraint = constraints.firstSatisfying ( c ) ->\n                pseudoChildren( c.pattern ).length > 0 and \\\n                not isExpressionFunctionApplication c.pattern\n            if constraint?\n                LHS = constraint.pattern\n                RHS = constraint.expression\n                if LHS.type isnt RHS.type\n                    matchDebug '\\tnon-atomic case, type fail:',\n                        CToString constraint\n                    return [ null, null ]\n                leftChildren = pseudoChildren LHS\n                rightChildren = pseudoChildren RHS\n                if leftChildren.length isnt rightChildren.length\n                    matchDebug '\\tnon-atomic case, #children fail:',\n                        CToString constraint\n                    return [ null, null ]\n                constraints = constraints.minus( constraint ).plus \\\n                    ( new Constraint( child, rightChildren[index] ) \\\n                        for child, index in leftChildren )...\n                matchDebug '\\tnon-atomic case, recur:', CToString constraint\n                return nextMatch constraints, solution, iterator\n\nWe do not implement the inconsistent case from the paper here, assuming that\nit has been weeded out by the caller before this point, usually at the level\nof rule validation, using the `consistentPatterns` function implemented\nearlier in this file.\n\nMetavariable case:  If there is a constraint whose left hand side is a\nsingle metavariable, then we attempt to resolve it.  If that metavariable is\nalready set in the solution, then the constraint under consideration must\nagree with it; this either results in continued processing or immediately\nreturning null, depending on that agreement check.  If the metavariable is\nnot already in the solution, then the constraint under consideration lets us\nadd it.\n\n            constraint = constraints.firstSatisfying ( c ) ->\n                isMetavariable c.pattern\n            if constraint?\n                if alreadySetTo = solution.lookup constraint.pattern\n                    if not constraint.expression.equals alreadySetTo, no\n                        matchDebug '\\tmetavariable case, mismatch:',\n                            CToString constraint\n                        return [ null, null ]\n                    else\n                        matchDebug '\\tmetavariable case, already set:',\n                            CToString constraint\n                else\n                    matchDebug '\\tmetavariable case, assigning:',\n                        CToString constraint\n                    solution = solution.plus constraint.copy()\n                return nextMatch constraints.minus( constraint ),\n                    solution, iterator\n\nFirst of two expression function application cases:  If there are two\nconstraints whose left hand sides are both expression function applications,\nand both use the same metavariable for the expression function, but the two\nright hand sides are different, we can narrow down the meaning of the\nmetavariable, and in each of some number of cases, compute the meaning of\nthe arguments to the expression function applications.\n\n            pair = constraints.firstPairSatisfying ( c1, c2 ) ->\n                isExpressionFunctionApplication( c1.pattern ) and \\\n                isExpressionFunctionApplication( c2.pattern ) and \\\n                c1.pattern.children[1].equals(\n                    c2.pattern.children[1], no ) and \\\n                not c1.expression.equals c2.expression, no\n            if pair?\n                [ c1, c2 ] = pair\n                smallerC = constraints.minus c1, c2\n                metavariable = c1.pattern.children[1]\n                t1 = c1.pattern.children[2]\n                t2 = c2.pattern.children[2]\n                e1 = c1.expression\n                e2 = c2.expression\n                makeMValue = ( subset ) ->\n                    v = constraints.nextNewVariable()\n                    makeExpressionFunction v, multiReplace e1, subset, v\n                iterator = differenceIterator e1, e2\n                iterator = filterIterator iterator, ( subset ) ->\n                    mValue = solution.lookup metavariable\n                    not mValue? or alphaEquivalent mValue, makeMValue subset\n                iterator = composeIterator iterator, ( subset ) ->\n                    maybeExtended = if solution.lookup metavariable\n                        solution.copy()\n                    else\n                        solution.plus new Constraint metavariable,\n                            makeMValue subset\n                    [ smallerC.plus(\n                        new Constraint( t1, e1.index subset[0] ),\n                        new Constraint( t2, e2.index subset[0] ) ),\n                      maybeExtended, null ]\n                matchDebug '\\tefa case 1 of 2, iterating:',\n                    CToString( c1 ), CToString( c2 )\n                return nextMatch smallerC, solution, iterator\n\nSecond of two expression function application cases:  If there are two\nconstraints whose left hand sides are both expression function applications,\nand both use the same metavariable for the expression function, and the two\nright hand sides are equal, we can narrow down the meaning of the\nmetavariable, and in each of some number of cases, compute the meaning of\nthe arguments to the expression function applications.  (Note that because\nthe constraint set is indeed a set, in this situation we know that the two\nparameters to the expression functions must be different.)\n\n            pair = constraints.firstPairSatisfying ( c1, c2 ) ->\n                isExpressionFunctionApplication( c1.pattern ) and \\\n                isExpressionFunctionApplication( c2.pattern ) and \\\n                c1.pattern.children[1].equals(\n                    c2.pattern.children[1], no ) and \\\n                c1.expression.equals c2.expression, no\n            if pair?\n                [ c1, c2 ] = pair\n                smallerC = constraints.minus c1, c2\n                metavariable = c1.pattern.children[1]\n                t1 = c1.pattern.children[2]\n                t2 = c2.pattern.children[2]\n                e = c1.expression\n                makeMValue = ( subset ) ->\n                    v = constraints.nextNewVariable()\n                    makeExpressionFunction v, multiReplace e, subset, v\n                iterator = subexpressionIterator e\n                iterator = filterIterator iterator, ( subset ) ->\n                    mValue = solution.lookup metavariable\n                    not mValue? or alphaEquivalent mValue, makeMValue subset\n                iterator = suffixIterator iterator, [ ]\n                iterator = composeIterator iterator, ( subset ) ->\n                    newMValue = makeMValue subset\n                    if oldMValue = solution.lookup metavariable\n                        if not alphaEquivalent oldMValue, newMValue\n                            return null\n                        maybeExtended = solution.copy()\n                    else\n                        maybeExtended = solution.plus \\\n                            new Constraint metavariable, newMValue\n                    newConstraints = smallerC\n                    if subset.length isnt 0\n                        newConstraints = newConstraints.plus \\\n                            new Constraint( t1, e.index subset[0] ),\n                            new Constraint( t2, e.index subset[0] )\n                    [ newConstraints, maybeExtended, null ]\n                matchDebug '\\tefa case 2 of 2, iterating:',\n                    CToString( c1 ), CToString( c2 )\n                return nextMatch smallerC, solution, iterator\n\nOnly remaining case:  Take the first constraint, which we know must be an\nexpression function application whose expression function is a metavariable\nthat appears in no other constraint.  Create all possible instantiations for\nthat metavariable as follows.\n\n            constraint = constraints.contents[0]\n            if not isExpressionFunctionApplication constraint.pattern\n                throw Error 'Invalid assumption in final case of matching'\n            smallerC = constraints.minus constraint\n            metavariable = constraint.pattern.children[1]\n            t = constraint.pattern.children[2]\n            e = constraint.expression\n            if mValue = solution.lookup metavariable\n                applied = applyExpressionFunction mValue, t\n                matchDebug '\\tfinal case, applying known metavariable:',\n                    CToString constraint\n                return nextMatch smallerC.plus( new Constraint mValue, e ),\n                    solution, iterator\n            makeMValue = ( subset ) ->\n                v = constraints.nextNewVariable()\n                makeExpressionFunction v, multiReplace e, subset, v\n            iterator = subexpressionIterator e\n            iterator = filterIterator iterator, ( subset ) ->\n                mValue = solution.lookup metavariable\n                not mValue? or alphaEquivalent mValue, makeMValue subset\n            iterator = suffixIterator iterator, [ ]\n            iterator = composeIterator iterator, ( subset ) ->\n                matchDebug '\\t\\tnext subexpression, with subset',\n                    JSON.stringify( subset ), 'solution',\n                    CLToString( solution ), 'constraints',\n                    CLToString( smallerC ), 't', t.simpleEncode(), 'e'\n                    e.simpleEncode(), 'metavariable',\n                    metavariable.simpleEncode()\n                newMValue = makeMValue subset\n                if oldMValue = solution.lookup metavariable\n                    if not alphaEquivalent oldMValue, newMValue\n                        return null\n                    maybeExtended = solution.copy()\n                else\n                    maybeExtended = solution.plus \\\n                        new Constraint metavariable, newMValue\n                newConstraints = smallerC\n                if subset.length isnt 0\n                    newConstraints = newConstraints.plus \\\n                        new Constraint t, e.index subset[0]\n                [ newConstraints, maybeExtended, null ]\n            matchDebug '\\tfinal case, iterating:', CToString constraint\n            return nextMatch smallerC, solution, iterator\n\nNow handle the case where this call was given an iterator, so we are\nessentially just executing a union operation over all calls of that\niterator.\n\n        else\n            next = iterator()\n            if next is null\n                matchDebug '\\titerator case, next is null, done!'\n                return [ null, null ]\n            [ nextConstraints, nextSolution, nextIterator ] = next\n            matchDebug '\\titerator case, using iterator.next():',\n                CLToString( nextConstraints ), CLToString( nextSolution ),\n                nextIterator?, '\\n--->'\n            [ nextResult, nextArguments ] =\n                nextMatch nextConstraints, nextSolution, nextIterator\n            if not nextResult?\n                matchDebug '\\n<---\\n' + \\\n                    '\\tafter iterator recursion, no result;\n                    keep iterating...'\n                return nextMatch constraints, solution, iterator\n            if not nextArguments?\n                matchDebug '\\n<---\\n\\tafter iterator recursion, ' + \\\n                    'got a unique solution:', CLToString nextResult\n                return [ nextResult, [ constraints, solution, iterator ] ]\n            matchDebug '\\n<---\\n\\tafter iterator recursion, ' + \\\n                'got a(nother?) solution:', CLToString( nextResult ),\n                'PLUS nextArguments', CLToString( nextArguments[0] ),\n                CLToString( nextArguments[1] ), nextArguments[2]?\n            nextArguments[2] = concatenateIterators \\\n                nextArguments[2], iterator\n            return [ nextResult, nextArguments ]\n\n## Context\n\nThe following lines ensure that this file works in Node.js, for testing.\n\n    if exports?\n        exports.setMetavariable = setMetavariable\n        exports.clearMetavariable = clearMetavariable\n        exports.isMetavariable = isMetavariable\n        exports.makeExpressionFunction = makeExpressionFunction\n        exports.isExpressionFunction = isExpressionFunction\n        exports.makeExpressionFunctionApplication = makeExpressionFunctionApplication\n        exports.isExpressionFunctionApplication = isExpressionFunctionApplication\n        exports.applyExpressionFunction = applyExpressionFunction\n        exports.alphaEquivalent = alphaEquivalent\n        exports.consistentPatterns = consistentPatterns\n        exports.Constraint = Constraint\n        exports.ConstraintList = ConstraintList\n        exports.findDifferencesBetween = findDifferencesBetween\n        exports.parentAddresses = parentAddresses\n        exports.partitionedAddresses = partitionedAddresses\n        exports.expressionDepth = expressionDepth\n        exports.sameDepthAncestors = sameDepthAncestors\n        exports.differenceIterator = differenceIterator\n        exports.subexpressionIterator = subexpressionIterator\n        exports.prefixIterator = prefixIterator\n        exports.suffixIterator = suffixIterator\n        exports.composeIterator = composeIterator\n        exports.filterIterator = filterIterator\n        exports.concatenateIterators = concatenateIterators\n        exports.multiReplace = multiReplace\n        exports.bindingConstraints1 = bindingConstraints1\n        exports.satisfiesBindingConstraints1 = satisfiesBindingConstraints1\n        exports.bindingConstraints2 = bindingConstraints2\n        exports.satisfiesBindingConstraints2 = satisfiesBindingConstraints2\n        exports.setMatchDebug = setMatchDebug\n        exports.nextMatch = nextMatch\n        exports.OM = exports.OMNode = OM\n\nAnd the following lines test to see if this function is running in a\n[WebWorker](https://www.w3.org/TR/workers/), and if so, they install an\nevent handler for messages posted from the main thread, which exposes the\nkey API from this module to the outside, through message-passing.\n\n    if WorkerGlobalScope? or self?.importScripts?\n        ProblemStore = { }\n\nThis function adds a new problem to the problem store, with given left- and\nright-hand sides for its one constraint.  Each must be an `OMNode` instance.\n\n        newProblem = ( name, LHS, RHS ) ->\n            ProblemStore[name] =\n                bc1 : bindingConstraints1 LHS\n                bc2 : bindingConstraints2 LHS\n                results : [ ]\n                args : [ new ConstraintList new Constraint LHS, RHS ]\n\nThis function attempts to find the next solution to the given problem.  It\nbegins by calling `nextMatch`, the workhorse of this module.  The results\nwill be an object with these attributes:\n * `name` - the name of the problem, as given to this function\n * `success` - a boolean true or false, true meaning that there was another\n   solution to fetch, and it has been fetched, false meaning there are no\n   more solutions to fetch\n * `count` - the total number of solutions fetched so far, which will be one\n   more than the last time iff `success` is true (or zero if there never\n   were any solutions)\n * `solution` - an object mapping metavariable names to the JSON string\n   representations of OM trees, which can be decoded with `OM.decode()`\n\n\n        getSolution = ( name ) ->\n            if not ( problem = ProblemStore[name] )? then return\n            if problem.args?\n                [ result, problem.args ] = nextMatch problem.args...\n            else\n                result = null\n            if result? and \\\n               satisfiesBindingConstraints1( result, problem.bc1 ) and \\\n               satisfiesBindingConstraints2( result, problem.bc2 )\n\nAll binding constraints are satisfied, so this is a valid solution, as long\nas we haven't already reported it.\n\n                already = no\n                for earlier in problem.results\n                    if earlier.equals result\n                        already = yes\n                        break\n                if not already\n                    problem.results.push result\n                    return\n                        name : name\n                        solution : result\n                        count : problem.results.length\n                        success : yes\n\nIf `nextMatch` signalled that it should not be called again (by making\n`problem.args` null) then we return null to indicate there are no more\nsolutions.\n\n            if not problem.args?\n                return\n                    name : name\n                    count : problem.results.length\n                    success : no\n\nOtherwise we found a solution but it was one we've already seen, or that\ndidn't satisfy binding constraints, so we recur to seek the next one, if\nany.\n\n            nextSolution name\n\nNow we install an event handler that calls these two functions on behalf of\na client communicating with us, as a WebWorker, through message passing.\n\n        self.addEventListener 'message', ( event ) ->\n            switch event.data[0]\n\nPass `[ 'newProblem', 'name here', LHS, RHS ]` to create a new matching\nproblem.  We expect JSON strings of the LHS and RHS, which we convert to\n`OMNode` instances before passing to `newProblem()`.\n\n                when 'newProblem'\n                    [ command, name, LHS, RHS ] = event.data\n                    newProblem name, OM.decode( LHS ), OM.decode( RHS )\n\nPass `[ 'getSolution', 'problem name' ]` to fetch the next solution to the\nnamed problem, created by a call to `nextSolution()`.\n\n                when 'getSolution'\n                    [ command, name ] = event.data\n                    if ( result = getSolution name )?\n                        if result.solution?\n                            converted = { }\n                            for constraint in result.solution.contents\n                                converted[constraint.pattern.name] =\n                                    constraint.expression.encode()\n                            result.solution = converted\n                    self.postMessage result\n\nPass `[ 'deleteProblem', 'problem name' ]` to remove the named problem from\nmemory.\n\n                when 'deleteProblem'\n                    [ command, name ] = event.data\n                    delete ProblemStore[name]\n"]}